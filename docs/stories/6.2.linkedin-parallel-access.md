# Story 6.2: Parallel LinkedIn Profile Matching

## Status

**Draft**

## Story

**As a** user,
**I want** efficient parallel LinkedIn profile matching,
**so that** member matching completes in reasonable time.

## Acceptance Criteria

1. Multiple lab members processed in parallel via mcp-linkedin (updated from queue approach)
2. MCP server handles session and rate limiting internally
3. Progress shows "LinkedIn: Processing member X of Y"
4. Timeouts prevent blocking on slow requests
5. Failed requests don't block processing

## Tasks / Subtasks

- [ ] **Task 1: Implement Parallel Profile Matching** (AC: 1)
  - [ ] Process multiple members concurrently
  - [ ] Use asyncio for parallel MCP calls
  - [ ] mcp-linkedin handles rate limiting internally

- [ ] **Task 2: Handle MCP Server Rate Limits** (AC: 2)
  - [ ] MCP server manages LinkedIn rate limits internally
  - [ ] Application respects MCP backpressure signals
  - [ ] Implement retry on rate limit responses:
    - Max retries: 3 attempts
    - Backoff strategy: Exponential with jitter
    - Initial delay: 2 seconds
    - Max delay: 30 seconds
  - [ ] Log rate limit events at WARNING level

- [ ] **Task 3: Implement Timeouts** (AC: 4)
  - [ ] 30 second timeout per LinkedIn search
  - [ ] Handle timeout gracefully

- [ ] **Task 4: Handle Failed Requests** (AC: 5)
  - [ ] Log failures
  - [ ] Continue with next member
  - [ ] Flag: "linkedin_match_failed"

## Dev Notes

### Source Tree Location
- Modify: `src/agents/linkedin_matcher.py`
- Use: `src/utils/mcp_client.py` (retry logic from Story 1.5)
- Use: `src/utils/logger.py` (from Story 1.7)

**Architecture Note:** mcp-linkedin MCP server handles session management and rate limiting internally. No queue needed in application code.

### MCP Backpressure Detection & Handling

**How to Detect Backpressure:**

MCP server signals backpressure via:
1. `MCPRateLimitError` exception - LinkedIn rate limit hit
2. Response delay > 10 seconds - Server throttling
3. 429 status codes in MCP responses

**Handling Strategy:**

```python
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type
from src.utils.mcp_client import search_linkedin_profile, MCPRateLimitError
from src.utils.logger import get_logger

logger = get_logger(correlation_id=run_id, phase="linkedin_parallel", component="linkedin_matcher")

@retry(
    retry=retry_if_exception_type(MCPRateLimitError),
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=2, min=2, max=30),
    reraise=True
)
async def match_with_retry(member: LabMember):
    try:
        return await search_linkedin_profile(member.name, university)
    except MCPRateLimitError as e:
        logger.warning("Rate limit hit, retrying", member=member.name, attempt=e.attempt)
        raise  # Retry via tenacity
```

### Parallel Processing with Concurrency Limits

**Problem:** Too many parallel requests overwhelm MCP server

**Solution:** Use asyncio.Semaphore to limit concurrency

```python
import asyncio

async def match_lab_members(members: list[LabMember], max_concurrent: int = 5):
    semaphore = asyncio.Semaphore(max_concurrent)

    async def match_with_limit(member: LabMember):
        async with semaphore:
            return await match_single_member(member)

    tasks = [match_with_limit(m) for m in members]
    results = await asyncio.gather(*tasks, return_exceptions=True)

    # Handle results
    for member, result in zip(members, results):
        if isinstance(result, Exception):
            logger.error("Match failed", member=member.name, error=str(result))
            member.data_quality_flags.append("linkedin_match_failed")
        else:
            # Process successful result
            pass
```

**Configuration:** `max_concurrent=5` (configurable in config.json under `batch_sizes.linkedin`)

### Testing

**Test File Location:** `tests/unit/test_linkedin_parallel.py`, `tests/integration/test_linkedin_rate_limits.py`

**Test Approach:** Unit tests (mock parallel execution) + Integration tests (simulated rate limits)

**Key Test Scenarios:**

1. **Parallel Processing Success** (Unit)
   - Mock `match_single_member()` for 10 members
   - Call `match_lab_members()` with max_concurrent=5
   - Assert all members processed
   - Verify concurrency limit respected (max 5 simultaneous)

2. **Rate Limit Retry Logic** (Unit)
   - Mock MCP to raise `MCPRateLimitError` on first 2 calls, succeed on 3rd
   - Call `match_with_retry()`
   - Assert 3 total attempts made
   - Verify exponential backoff delays (2s, 4s, 8s pattern)

3. **Timeout Handling** (Unit)
   - Mock MCP to timeout after 30 seconds
   - Verify `asyncio.TimeoutError` caught gracefully
   - Assert member flagged with `"linkedin_match_failed"`
   - Verify processing continues with next member

4. **Mixed Success/Failure** (Unit)
   - Mock 5 members: 3 succeed, 2 fail (1 timeout, 1 rate limit exceeded)
   - Call `match_lab_members()`
   - Assert 3 successful matches
   - Assert 2 failed members flagged appropriately
   - Verify all results handled correctly

**Success Criteria:**
- Concurrency limits prevent overwhelming MCP server
- Retry logic handles transient rate limit errors
- Timeouts don't block entire batch processing
- Failed matches flagged but don't crash system

**Test Data Requirements:**
- Mock LinkedIn profile responses for successful matches
- Timing data to verify exponential backoff

**Example Test Pattern:**
```python
import pytest
import asyncio
from unittest.mock import AsyncMock, patch
from src.agents.linkedin_matcher import match_lab_members
from src.models.lab_member import LabMember
from src.utils.mcp_client import MCPRateLimitError

@pytest.mark.asyncio
async def test_rate_limit_retry_succeeds():
    # Arrange
    member = LabMember(name="Jane Doe")
    call_count = 0

    async def mock_search_with_rate_limit(*args, **kwargs):
        nonlocal call_count
        call_count += 1
        if call_count < 3:
            raise MCPRateLimitError("Rate limit exceeded")
        return [{"name": "Jane Doe", "url": "https://linkedin.com/in/janedoe"}]

    with patch('src.utils.mcp_client.search_linkedin_profile', side_effect=mock_search_with_rate_limit):
        # Act
        result = await match_with_retry(member)

        # Assert
        assert call_count == 3  # Failed twice, succeeded on 3rd
        assert result is not None
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-06 | 0.1 | Initial story creation | Sarah (PO) |
| 2025-10-06 | 0.2 | Added retry strategy details, MCP backpressure handling, concurrency limits, testing guidance | Sarah (PO) |
