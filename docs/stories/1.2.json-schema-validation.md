# Story 1.2: JSON Configuration Schema & Validation

**Epic:** Epic 1 - Foundation & Configuration Infrastructure

**Status:** Not Started

---

## User Story

As a **user**,
I want **my configuration files validated against JSON schemas before execution**,
so that **I catch configuration errors early instead of during long-running analysis**.

---

## Acceptance Criteria

1. JSON schemas defined for: user profile config, university config, system parameters config
2. Schema validation logic implemented with clear error messages
3. Validation runs before any processing begins (FR1)
4. Missing required fields identified with helpful guidance
5. Type mismatches and invalid values caught with specific feedback
6. Example configuration files provided with inline comments
7. Validator utility module created in `src/utils/validator.py`

---

## Technical Details

### JSON Schemas to Create

**1. User Profile Schema:** `src/schemas/user_profile_schema.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "User Profile Configuration",
  "description": "User's academic profile for lab matching",
  "type": "object",
  "required": ["name", "current_degree", "target_university", "target_department", "research_interests"],
  "properties": {
    "name": {
      "type": "string",
      "description": "User's full name",
      "minLength": 1
    },
    "current_degree": {
      "type": "string",
      "description": "Current degree program (e.g., 'PhD in Computer Science')",
      "minLength": 1
    },
    "target_university": {
      "type": "string",
      "description": "University to analyze",
      "minLength": 1
    },
    "target_department": {
      "type": "string",
      "description": "Primary department of interest",
      "minLength": 1
    },
    "research_interests": {
      "type": "array",
      "description": "List of research interests",
      "items": {
        "type": "string",
        "minLength": 1
      },
      "minItems": 1
    },
    "resume_highlights": {
      "type": "object",
      "description": "Extracted resume sections",
      "properties": {
        "education": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "degree": {"type": "string"},
              "institution": {"type": "string"},
              "year": {"type": "integer"}
            }
          }
        },
        "skills": {
          "type": "array",
          "items": {"type": "string"}
        },
        "research_experience": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "title": {"type": "string"},
              "description": {"type": "string"},
              "duration": {"type": "string"}
            }
          }
        }
      }
    },
    "preferred_graduation_duration": {
      "type": "number",
      "description": "Average PhD graduation duration in years for timeline calculations",
      "default": 5.5,
      "minimum": 3.0,
      "maximum": 10.0
    }
  }
}
```

**2. University Config Schema:** `src/schemas/university_config_schema.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "University Configuration",
  "description": "Target university details and structure",
  "type": "object",
  "required": ["university_name", "core_website", "directory_link"],
  "properties": {
    "university_name": {
      "type": "string",
      "description": "Full university name",
      "minLength": 1
    },
    "core_website": {
      "type": "string",
      "description": "University main website URL",
      "format": "uri"
    },
    "directory_link": {
      "type": "string",
      "description": "Faculty directory URL",
      "format": "uri"
    },
    "department_structure_hint": {
      "type": "string",
      "description": "Optional hint about multi-layered structure (e.g., 'School > Division > Department')",
      "examples": ["School of Medicine > Divisions > Departments"]
    },
    "known_departments": {
      "type": "array",
      "description": "Optional list of known relevant departments",
      "items": {
        "type": "string"
      }
    }
  }
}
```

**3. System Parameters Schema:** `src/schemas/system_params_schema.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "System Parameters Configuration",
  "description": "System execution and batch processing parameters",
  "type": "object",
  "properties": {
    "batch_sizes": {
      "type": "object",
      "description": "Batch sizes for parallel processing",
      "properties": {
        "departments": {
          "type": "integer",
          "description": "Number of departments to process in parallel",
          "default": 5,
          "minimum": 1,
          "maximum": 20
        },
        "professors": {
          "type": "integer",
          "description": "Number of professors to filter in parallel",
          "default": 20,
          "minimum": 5,
          "maximum": 50
        },
        "labs": {
          "type": "integer",
          "description": "Number of labs to analyze in parallel",
          "default": 10,
          "minimum": 1,
          "maximum": 30
        }
      }
    },
    "rate_limits": {
      "type": "object",
      "description": "Rate limiting per data source (requests per minute)",
      "properties": {
        "archive_org": {
          "type": "integer",
          "description": "Archive.org requests per minute",
          "default": 30,
          "minimum": 5
        },
        "linkedin": {
          "type": "integer",
          "description": "LinkedIn requests per minute",
          "default": 10,
          "minimum": 1
        },
        "paper_search": {
          "type": "integer",
          "description": "Paper search requests per minute",
          "default": 20,
          "minimum": 5
        }
      }
    },
    "timeouts": {
      "type": "object",
      "description": "Timeout values in seconds",
      "properties": {
        "web_scraping": {
          "type": "integer",
          "description": "Web scraping timeout (seconds)",
          "default": 30,
          "minimum": 10
        },
        "mcp_query": {
          "type": "integer",
          "description": "MCP query timeout (seconds)",
          "default": 60,
          "minimum": 10
        }
      }
    },
    "confidence_thresholds": {
      "type": "object",
      "description": "Minimum confidence scores for matching",
      "properties": {
        "professor_filter": {
          "type": "number",
          "description": "Minimum confidence for professor filtering",
          "default": 70.0,
          "minimum": 0.0,
          "maximum": 100.0
        },
        "linkedin_match": {
          "type": "number",
          "description": "Minimum confidence for LinkedIn profile matching",
          "default": 75.0,
          "minimum": 0.0,
          "maximum": 100.0
        }
      }
    },
    "publication_years": {
      "type": "integer",
      "description": "Number of recent years to search for publications",
      "default": 3,
      "minimum": 1,
      "maximum": 10
    },
    "log_level": {
      "type": "string",
      "description": "Logging level",
      "enum": ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
      "default": "INFO"
    }
  }
}
```

### Validator Module

Create `src/utils/validator.py`:

```python
"""
Configuration Validator Module
Validates JSON configuration files against schemas.
"""

import json
from pathlib import Path
from typing import Any, Dict, List, Optional

import jsonschema
from jsonschema import Draft7Validator, ValidationError
from rich.console import Console

console = Console()

class ConfigurationError(Exception):
    """Raised when configuration validation fails."""
    pass

class ConfigValidator:
    """Validates configuration files against JSON schemas."""

    def __init__(self, schema_dir: Path = Path("src/schemas")):
        """
        Initialize validator with schema directory.

        Args:
            schema_dir: Path to directory containing JSON schemas
        """
        self.schema_dir = schema_dir
        self._schemas: Dict[str, Dict[str, Any]] = {}

    def load_schema(self, schema_name: str) -> Dict[str, Any]:
        """
        Load JSON schema from file.

        Args:
            schema_name: Schema filename (e.g., "user_profile_schema.json")

        Returns:
            Loaded schema dictionary

        Raises:
            ConfigurationError: If schema file not found or invalid
        """
        if schema_name in self._schemas:
            return self._schemas[schema_name]

        schema_path = self.schema_dir / schema_name
        if not schema_path.exists():
            raise ConfigurationError(f"Schema file not found: {schema_path}")

        try:
            with open(schema_path, "r", encoding="utf-8") as f:
                schema = json.load(f)
            self._schemas[schema_name] = schema
            return schema
        except json.JSONDecodeError as e:
            raise ConfigurationError(f"Invalid JSON in schema {schema_name}: {e}")

    def validate(
        self,
        config: Dict[str, Any],
        schema_name: str
    ) -> None:
        """
        Validate configuration against schema.

        Args:
            config: Configuration dictionary to validate
            schema_name: Schema filename to validate against

        Raises:
            ConfigurationError: If validation fails with detailed error messages
        """
        schema = self.load_schema(schema_name)
        validator = Draft7Validator(schema)

        errors = list(validator.iter_errors(config))
        if not errors:
            return

        # Format error messages
        error_messages = self._format_validation_errors(errors, schema_name)
        raise ConfigurationError("\n".join(error_messages))

    def validate_file(
        self,
        config_path: Path,
        schema_name: str
    ) -> Dict[str, Any]:
        """
        Load and validate configuration file.

        Args:
            config_path: Path to configuration JSON file
            schema_name: Schema filename to validate against

        Returns:
            Validated configuration dictionary

        Raises:
            ConfigurationError: If file not found or validation fails
        """
        if not config_path.exists():
            raise ConfigurationError(f"Configuration file not found: {config_path}")

        try:
            with open(config_path, "r", encoding="utf-8") as f:
                config = json.load(f)
        except json.JSONDecodeError as e:
            raise ConfigurationError(
                f"Invalid JSON in {config_path.name}: {e}\n"
                f"Check for trailing commas, missing quotes, or invalid syntax."
            )

        self.validate(config, schema_name)
        return config

    def _format_validation_errors(
        self,
        errors: List[ValidationError],
        schema_name: str
    ) -> List[str]:
        """
        Format validation errors into user-friendly messages.

        Args:
            errors: List of validation errors from jsonschema
            schema_name: Schema name for context

        Returns:
            List of formatted error messages
        """
        messages = [f"\n❌ Configuration validation failed for {schema_name}:\n"]

        for error in errors:
            # Build path to error location
            path = " → ".join([str(p) for p in error.absolute_path]) or "(root)"

            # Format specific error types
            if error.validator == "required":
                missing_field = error.message.split("'")[1]
                messages.append(
                    f"  • Missing required field: '{missing_field}' at {path}\n"
                    f"    → Add this field to your configuration file"
                )
            elif error.validator == "type":
                messages.append(
                    f"  • Type mismatch at '{path}': {error.message}\n"
                    f"    → Expected type: {error.validator_value}"
                )
            elif error.validator == "minLength":
                messages.append(
                    f"  • Value too short at '{path}': {error.message}"
                )
            elif error.validator == "format":
                messages.append(
                    f"  • Invalid format at '{path}': {error.message}\n"
                    f"    → Expected format: {error.validator_value} (e.g., valid URL)"
                )
            elif error.validator == "minimum":
                messages.append(
                    f"  • Value too small at '{path}': {error.message}"
                )
            elif error.validator == "maximum":
                messages.append(
                    f"  • Value too large at '{path}': {error.message}"
                )
            elif error.validator == "enum":
                messages.append(
                    f"  • Invalid value at '{path}': {error.message}\n"
                    f"    → Allowed values: {error.validator_value}"
                )
            else:
                messages.append(f"  • Validation error at '{path}': {error.message}")

        messages.append("\n💡 Fix the errors above and try again.\n")
        return messages

    def validate_all_configs(
        self,
        user_profile_path: Path,
        university_config_path: Path,
        system_params_path: Optional[Path] = None
    ) -> Dict[str, Dict[str, Any]]:
        """
        Validate all required configuration files.

        Args:
            user_profile_path: Path to user profile JSON
            university_config_path: Path to university config JSON
            system_params_path: Optional path to system parameters JSON

        Returns:
            Dictionary with validated configs: {"user_profile": {...}, "university": {...}, "system_params": {...}}

        Raises:
            ConfigurationError: If any validation fails
        """
        console.print("\n🔍 Validating configuration files...\n")

        configs = {}

        # Validate user profile
        console.print("  Validating user profile...")
        configs["user_profile"] = self.validate_file(
            user_profile_path,
            "user_profile_schema.json"
        )
        console.print("  ✅ User profile valid\n")

        # Validate university config
        console.print("  Validating university configuration...")
        configs["university"] = self.validate_file(
            university_config_path,
            "university_config_schema.json"
        )
        console.print("  ✅ University configuration valid\n")

        # Validate system parameters (optional, use defaults if not provided)
        if system_params_path and system_params_path.exists():
            console.print("  Validating system parameters...")
            configs["system_params"] = self.validate_file(
                system_params_path,
                "system_params_schema.json"
            )
            console.print("  ✅ System parameters valid\n")
        else:
            console.print("  ℹ️  No system parameters file provided, using defaults\n")
            configs["system_params"] = {}

        console.print("✅ All configuration files validated successfully!\n")
        return configs
```

### Example Configuration Files

**config/user_profile.example.json:**
```json
{
  "name": "Jane Doe",
  "current_degree": "PhD in Computer Science",
  "target_university": "Stanford University",
  "target_department": "Computer Science",
  "research_interests": [
    "Machine Learning",
    "Natural Language Processing",
    "Artificial Intelligence"
  ],
  "resume_highlights": {
    "education": [
      {
        "degree": "MS in Computer Science",
        "institution": "University of California, Berkeley",
        "year": 2022
      }
    ],
    "skills": [
      "Python",
      "TensorFlow",
      "PyTorch",
      "Research Writing"
    ],
    "research_experience": [
      {
        "title": "Research Assistant - NLP Lab",
        "description": "Developed transformer models for question answering",
        "duration": "2021-2022"
      }
    ]
  },
  "preferred_graduation_duration": 5.5
}
```

**config/university_config.example.json:**
```json
{
  "university_name": "Stanford University",
  "core_website": "https://www.stanford.edu",
  "directory_link": "https://www.stanford.edu/faculty-staff",
  "department_structure_hint": "Schools > Departments",
  "known_departments": [
    "Computer Science",
    "Electrical Engineering",
    "Bioengineering"
  ]
}
```

**config/system_params.example.json:**
```json
{
  "batch_sizes": {
    "departments": 5,
    "professors": 20,
    "labs": 10
  },
  "rate_limits": {
    "archive_org": 30,
    "linkedin": 10,
    "paper_search": 20
  },
  "timeouts": {
    "web_scraping": 30,
    "mcp_query": 60
  },
  "confidence_thresholds": {
    "professor_filter": 70.0,
    "linkedin_match": 75.0
  },
  "publication_years": 3,
  "log_level": "INFO"
}
```

---

## Implementation Steps

1. **Create schema directory:**
   ```bash
   mkdir -p src/schemas
   ```

2. **Create JSON schema files:**
   - Create `src/schemas/user_profile_schema.json`
   - Create `src/schemas/university_config_schema.json`
   - Create `src/schemas/system_params_schema.json`

3. **Create validator module:**
   - Create `src/utils/validator.py` with ConfigValidator class

4. **Create example configuration files:**
   - Create `config/user_profile.example.json`
   - Create `config/university_config.example.json`
   - Create `config/system_params.example.json`

5. **Update .gitignore:**
   ```gitignore
   # User configuration files (contain PII)
   config/user_profile.json
   config/university_config.json
   config/system_params.json
   ```

6. **Test validator:**
   - Create test with valid config
   - Create test with invalid config (missing field)
   - Create test with type mismatch
   - Verify error messages are helpful

7. **Commit changes:**
   ```bash
   git add src/schemas/ src/utils/validator.py config/*.example.json
   git commit -m "Add JSON schema validation for configuration files"
   ```

---

## Dependencies

**Prerequisites:**
- Story 1.1 (Core Dependency Installation) must be complete (requires jsonschema, pydantic, rich)

**Depends On:**
- Story 1.1: Core Dependency Installation

**Blocks:**
- Story 1.7: User Profile Consolidation (requires validated configs)
- All Epic 2+ stories (require validated configuration before execution)

---

## Testing

### Test File Location

`tests/unit/test_validator.py`

### Test Cases

1. **Test valid configurations pass:**
   - Load example configs and verify no errors

2. **Test missing required fields:**
   - Remove required field, verify specific error message

3. **Test type mismatches:**
   - Use string where integer expected, verify error

4. **Test format validation:**
   - Use invalid URL, verify format error

5. **Test range validation:**
   - Use value outside min/max range, verify error

6. **Test enum validation:**
   - Use invalid log_level, verify enum error

7. **Test helpful error messages:**
   - Verify error messages include field path and fix suggestions

### Example Test

```python
def test_missing_required_field_shows_helpful_error(tmp_path):
    # Arrange
    validator = ConfigValidator()
    config = {
        "name": "Jane Doe",
        # Missing "current_degree" (required)
        "target_university": "Stanford",
        "target_department": "CS",
        "research_interests": ["ML"]
    }

    # Act & Assert
    with pytest.raises(ConfigurationError) as exc_info:
        validator.validate(config, "user_profile_schema.json")

    error_message = str(exc_info.value)
    assert "Missing required field: 'current_degree'" in error_message
    assert "Add this field to your configuration file" in error_message
```

---

## Notes

- **User-Friendly Errors:** Error messages must be clear for non-technical users
- **Example Files:** .example.json files demonstrate proper structure
- **Security:** Actual user configs are .gitignored (contain PII)
- **Schema Evolution:** If schemas change, update version in $schema field
- **Validation Timing:** Validation runs at startup before any processing (FR1)

---

## References

- **PRD:** `docs/prd.md` - FR1 (JSON Schema validation), Epic 1 Story 1.2
- **Architecture:** `docs/architecture.md` - Data Models section
